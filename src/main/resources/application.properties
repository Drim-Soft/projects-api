spring.application.name=projectsapi
# ===============================
# Server Configuration
# ===============================
server.port=${SERVER_PORT:8080}
server.servlet.context-path=${SERVER_SERVLET_CONTEXT_PATH:/api/v1}

# ===============================
# DATABASE - Supabase PostgreSQL
# ===============================
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect



spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
spring.datasource.hikari.data-source-properties.prepareThreshold=0

# ======================================================
# HikariCP Pool Tuning (Supabase max connections mitigation)
# ======================================================
# Supabase (plan básico) suele permitir ~20 conexiones totales. Limitar el pool evita "remaining connection slots are reserved".
# Ajusta estos valores solo aquí (sin variables de entorno) como solicitaste.
# Máximo de conexiones simultáneas que este backend abrirá al Postgres.
spring.datasource.hikari.maximum-pool-size=10
# Mínimo de conexiones inactivas mantenidas (reduce picos de creación/destrucción).
spring.datasource.hikari.minimum-idle=5
# Tiempo máximo esperando una conexión libre antes de lanzar excepción (ms).
spring.datasource.hikari.connection-timeout=30000
# Tiempo máximo que una conexión puede permanecer inactiva antes de ser cerrada (ms).
spring.datasource.hikari.idle-timeout=600000
# Vida máxima de una conexión antes de reciclarla (ms) < límites del servidor para prevenir cortes abruptos.
spring.datasource.hikari.max-lifetime=1800000
# Enviar pings de keepalive para evitar desconexiones inesperadas (ms). Opcional: reduce reconexiones en ambientes con NAT.
spring.datasource.hikari.keepalive-time=300000
# Detectar potenciales fugas de conexiones (ms). Si un hilo retiene una conexión > threshold se loguea WARNING.
spring.datasource.hikari.leak-detection-threshold=20000
# Timeout de validación de conexión (ms) al hacer health-check interno.
spring.datasource.hikari.validation-timeout=5000

# Desactivar Open Session in View para liberar la conexión al terminar el servicio y no al cerrar la respuesta HTTP.
spring.jpa.open-in-view=false

# Optimización Hibernate para LOB sin contexto.
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

# Forzar auto-commit false en Hikari para que Hibernate gestione las transacciones correctamente.
spring.datasource.hikari.auto-commit=false


# ===============================
# Supabase API (para consumo externo)
# ===============================
supabase.url=${SUPABASE_URL}
supabase.anon.key=${SUPABASE_ANON_KEY}
supabase.service.key=${SUPABASE_SERVICE_KEY}
supabase.jwt.secret=${SUPABASE_JWT_SECRET}

# ===============================
# Supabase Storage S3 Configuration
# ===============================
supabase.storage.endpoint=${SUPABASE_STORAGE_ENDPOINT:https://rniqzbnygegbkecikbxj.storage.supabase.co/storage/v1/s3}
supabase.storage.access.key=${SUPABASE_STORAGE_ACCESS_KEY}
supabase.storage.secret.key=${SUPABASE_STORAGE_SECRET_KEY}
supabase.storage.region=${SUPABASE_STORAGE_REGION:us-east-1}

# ===============================
# General Configuration
# ===============================
spring.docker.compose.enabled=false
spring.config.import=optional:file:.env[.properties]

# ===============================
# Observabilidad - Prometheus & Actuator
# ===============================
management.endpoint.health.probes.enabled=true
management.endpoints.web.exposure.include=health,info,prometheus,metrics
management.metrics.export.prometheus.enabled=true
management.endpoint.health.show-details=always
management.server.base-path=/actuator

spring.security.user.name=metrics
spring.security.user.password=metrics123